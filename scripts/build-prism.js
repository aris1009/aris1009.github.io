#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { rollup } from 'rollup';
import nodeResolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Load Prism's official components.json
 */
function loadPrismComponents() {
  const componentsPath = path.join(process.cwd(), 'node_modules', 'prismjs', 'components.json');
  try {
    const content = fs.readFileSync(componentsPath, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.warn('Could not load Prism components.json:', error.message);
    return null;
  }
}

/**
 * PrismJS Bundle Builder
 *
 * Reads detected languages from src/_data/detectedLanguages.json
 * and generates an optimized Prism bundle with only needed languages.
 */

// Configuration
const CONFIG = {
  detectedLanguagesPath: path.join(__dirname, '..', 'src', '_data', 'detectedLanguages.json'),
  outputPath: path.join(__dirname, '..', 'src', '_static', 'js', 'prism.js'),
  tempEntryPath: path.join(__dirname, '.prism-entry.js'),

  // Fallback languages if detection file doesn't exist
  fallbackLanguages: ['markup', 'css', 'clike', 'javascript', 'bash', 'python', 'json', 'typescript'],
};

/**
 * Read detected languages from JSON file
 */
function readDetectedLanguages() {
  try {
    if (fs.existsSync(CONFIG.detectedLanguagesPath)) {
      const content = fs.readFileSync(CONFIG.detectedLanguagesPath, 'utf8');
      const data = JSON.parse(content);
      return data.bundleLanguages || CONFIG.fallbackLanguages;
    }
  } catch (error) {
    console.warn('Could not read detected languages, using fallback:', error.message);
  }
  return CONFIG.fallbackLanguages;
}

/**
 * Generate Prism entry file content
 * Imports core + detected languages in correct order
 */
function generateEntryContent(languages) {
  const lines = [
    '// Auto-generated Prism entry file',
    '// Do not edit manually - generated by build-prism.js',
    '',
    "import Prism from 'prismjs';",
    '',
    '// Import detected languages',
  ];

  // Filter out core (already in Prism base) and order by dependencies
  const languagesToImport = orderLanguagesByDependency(languages);

  for (const lang of languagesToImport) {
    // Skip core languages that are built into Prism base
    if (['markup', 'css', 'clike', 'javascript'].includes(lang)) {
      continue;
    }
    lines.push(`import 'prismjs/components/prism-${lang}';`);
  }

  lines.push('');
  lines.push('// Make Prism available globally');
  lines.push('window.Prism = Prism;');
  lines.push('');
  lines.push('export default Prism;');

  return lines.join('\n');
}

/**
 * Build dependency graph from Prism's components.json
 */
function buildDependencyGraph(componentsData) {
  const graph = {};
  const languages = componentsData?.languages || {};

  for (const [lang, data] of Object.entries(languages)) {
    const requires = data.require;
    const deps = requires ? (Array.isArray(requires) ? requires : [requires]) : [];
    graph[lang] = deps;
  }

  return graph;
}

/**
 * Topological sort to order languages by dependencies
 * Languages with no dependencies come first, then languages that depend on them, etc.
 */
function topologicalSort(languages, dependencyGraph) {
  const sorted = [];
  const visited = new Set();
  const visiting = new Set();

  function visit(lang) {
    if (visited.has(lang)) return;
    if (visiting.has(lang)) {
      // Circular dependency detected - just skip
      return;
    }

    visiting.add(lang);

    const deps = dependencyGraph[lang] || [];
    for (const dep of deps) {
      visit(dep);
    }

    visiting.delete(lang);
    visited.add(lang);
    sorted.push(lang);
  }

  for (const lang of languages) {
    visit(lang);
  }

  return sorted;
}

/**
 * Order languages by their dependencies (simpler ones first)
 * Uses Prism's components.json for dependency information
 */
function orderLanguagesByDependency(languages) {
  const componentsData = loadPrismComponents();

  if (!componentsData) {
    // Fallback: return as-is
    console.warn('Using languages without dependency ordering');
    return [...languages];
  }

  const dependencyGraph = buildDependencyGraph(componentsData);
  return topologicalSort([...languages], dependencyGraph);
}

/**
 * Build the Prism bundle using Rollup
 */
async function buildBundle(entryContent) {
  // Write temporary entry file
  fs.writeFileSync(CONFIG.tempEntryPath, entryContent, 'utf8');

  try {
    const bundle = await rollup({
      input: CONFIG.tempEntryPath,
      plugins: [
        nodeResolve(),
        commonjs(),
        terser({
          format: { comments: false },
        }),
      ],
      onwarn(warning, warn) {
        // Suppress circular dependency warnings from Prism
        if (warning.code === 'CIRCULAR_DEPENDENCY') return;
        warn(warning);
      },
    });

    const { output } = await bundle.generate({
      format: 'iife',
      name: 'Prism',
    });

    // Get the generated code
    const code = output[0].code;

    // Ensure output directory exists
    const outputDir = path.dirname(CONFIG.outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write the bundle
    fs.writeFileSync(CONFIG.outputPath, code, 'utf8');

    await bundle.close();

    return code.length;
  } finally {
    // Clean up temp file
    if (fs.existsSync(CONFIG.tempEntryPath)) {
      fs.unlinkSync(CONFIG.tempEntryPath);
    }
  }
}

/**
 * Main entry point
 */
async function main() {
  console.log('Building optimized Prism bundle...\n');

  // Read detected languages
  const languages = readDetectedLanguages();
  console.log('Languages to include:', languages.join(', '));

  // Generate entry file content
  const entryContent = generateEntryContent(languages);

  // Build the bundle
  const bundleSize = await buildBundle(entryContent);

  const sizeKB = (bundleSize / 1024).toFixed(2);
  console.log(`\nBundle written to: ${CONFIG.outputPath}`);
  console.log(`Bundle size: ${sizeKB} KB`);
}

// Export for testing
export {
  loadPrismComponents,
  buildDependencyGraph,
  topologicalSort,
  readDetectedLanguages,
  generateEntryContent,
  orderLanguagesByDependency,
  buildBundle,
  CONFIG,
};

// Run main only when executed directly
const isMainModule = import.meta.url === `file://${process.argv[1]}`;
if (isMainModule) {
  main().catch(err => {
    console.error('Build failed:', err);
    process.exit(1);
  });
}
