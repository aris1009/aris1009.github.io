#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { rollup } from 'rollup';
import nodeResolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * PrismJS Bundle Builder
 *
 * Reads detected languages from src/_data/detectedLanguages.json
 * and generates an optimized Prism bundle with only needed languages.
 */

// Configuration
const CONFIG = {
  detectedLanguagesPath: path.join(__dirname, '..', 'src', '_data', 'detectedLanguages.json'),
  outputPath: path.join(__dirname, '..', 'src', '_static', 'js', 'prism.js'),
  tempEntryPath: path.join(__dirname, '.prism-entry.js'),

  // Fallback languages if detection file doesn't exist
  fallbackLanguages: ['markup', 'css', 'clike', 'javascript', 'bash', 'python', 'json', 'typescript'],
};

/**
 * Read detected languages from JSON file
 */
function readDetectedLanguages() {
  try {
    if (fs.existsSync(CONFIG.detectedLanguagesPath)) {
      const content = fs.readFileSync(CONFIG.detectedLanguagesPath, 'utf8');
      const data = JSON.parse(content);
      return data.bundleLanguages || CONFIG.fallbackLanguages;
    }
  } catch (error) {
    console.warn('Could not read detected languages, using fallback:', error.message);
  }
  return CONFIG.fallbackLanguages;
}

/**
 * Generate Prism entry file content
 * Imports core + detected languages in correct order
 */
function generateEntryContent(languages) {
  const lines = [
    '// Auto-generated Prism entry file',
    '// Do not edit manually - generated by build-prism.js',
    '',
    "import Prism from 'prismjs';",
    '',
    '// Import detected languages',
  ];

  // Filter out core (already in Prism base) and order by dependencies
  const languagesToImport = orderLanguagesByDependency(languages);

  for (const lang of languagesToImport) {
    // Skip core languages that are built into Prism base
    if (['markup', 'css', 'clike', 'javascript'].includes(lang)) {
      continue;
    }
    lines.push(`import 'prismjs/components/prism-${lang}';`);
  }

  lines.push('');
  lines.push('// Make Prism available globally');
  lines.push('window.Prism = Prism;');
  lines.push('');
  lines.push('export default Prism;');

  return lines.join('\n');
}

/**
 * Order languages by their dependencies (simpler ones first)
 */
function orderLanguagesByDependency(languages) {
  // Languages that depend on others should come after their dependencies
  const dependencyOrder = {
    'markup': 0,
    'css': 1,
    'clike': 2,
    'javascript': 3,
    'c': 4,
    'bash': 5,
    'json': 5,
    'yaml': 5,
    'python': 5,
    'go': 5,
    'rust': 5,
    'java': 5,
    'cpp': 6,
    'csharp': 6,
    'typescript': 7,
    'jsx': 8,
    'tsx': 9,
    'markdown': 10,
    'docker': 10,
    'git': 10,
    'diff': 10,
  };

  return [...languages].sort((a, b) => {
    const orderA = dependencyOrder[a] ?? 50;
    const orderB = dependencyOrder[b] ?? 50;
    return orderA - orderB;
  });
}

/**
 * Build the Prism bundle using Rollup
 */
async function buildBundle(entryContent) {
  // Write temporary entry file
  fs.writeFileSync(CONFIG.tempEntryPath, entryContent, 'utf8');

  try {
    const bundle = await rollup({
      input: CONFIG.tempEntryPath,
      plugins: [
        nodeResolve(),
        commonjs(),
        terser({
          format: { comments: false },
        }),
      ],
      onwarn(warning, warn) {
        // Suppress circular dependency warnings from Prism
        if (warning.code === 'CIRCULAR_DEPENDENCY') return;
        warn(warning);
      },
    });

    const { output } = await bundle.generate({
      format: 'iife',
      name: 'Prism',
    });

    // Get the generated code
    const code = output[0].code;

    // Ensure output directory exists
    const outputDir = path.dirname(CONFIG.outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write the bundle
    fs.writeFileSync(CONFIG.outputPath, code, 'utf8');

    await bundle.close();

    return code.length;
  } finally {
    // Clean up temp file
    if (fs.existsSync(CONFIG.tempEntryPath)) {
      fs.unlinkSync(CONFIG.tempEntryPath);
    }
  }
}

/**
 * Main entry point
 */
async function main() {
  console.log('Building optimized Prism bundle...\n');

  // Read detected languages
  const languages = readDetectedLanguages();
  console.log('Languages to include:', languages.join(', '));

  // Generate entry file content
  const entryContent = generateEntryContent(languages);

  // Build the bundle
  const bundleSize = await buildBundle(entryContent);

  const sizeKB = (bundleSize / 1024).toFixed(2);
  console.log(`\nBundle written to: ${CONFIG.outputPath}`);
  console.log(`Bundle size: ${sizeKB} KB`);
}

// Export for testing
export {
  readDetectedLanguages,
  generateEntryContent,
  orderLanguagesByDependency,
  buildBundle,
  CONFIG,
};

// Run main only when executed directly
const isMainModule = import.meta.url === `file://${process.argv[1]}`;
if (isMainModule) {
  main().catch(err => {
    console.error('Build failed:', err);
    process.exit(1);
  });
}
